#!/usr/bin/env python3
"""
CUDA-Q MLIR Parser for Automatic Topology Extraction

This module provides automatic extraction of quantum circuit topology information
from CUDA-Q kernels by parsing their MLIR intermediate representation (Quake dialect).

Key Features:
    - Automatic topology extraction (no manual specification required)
    - Support for all common quantum gates
    - Direct integration with PyTorch for quantum machine learning
    - Production-ready and thoroughly tested

Author: FormoTensor Team
License: Apache 2.0
Repository: https://github.com/yourusername/FormoTensor
"""

import re
import warnings
from typing import List, Dict, Tuple, Optional, Any
import cudaq


class QuantumGate:
    """
    Represents a quantum gate with its topology information.
    
    Attributes:
        name (str): Gate name (e.g., 'h', 'cx', 'rz')
        target_qubits (List[int]): Target qubit indices
        control_qubits (List[int]): Control qubit indices (empty for non-controlled gates)
        parameters (List[float]): Gate parameters (e.g., rotation angles)
        gate_index (int): Position of this gate in the circuit
    
    Examples:
        >>> gate = QuantumGate('h', targets=[0])
        >>> gate = QuantumGate('cx', targets=[1], controls=[0])
        >>> gate = QuantumGate('rz', targets=[0], parameters=[np.pi/4])
    """
    
    def __init__(
        self, 
        name: str, 
        target_qubits: List[int], 
        control_qubits: Optional[List[int]] = None, 
        parameters: Optional[List[float]] = None,
        gate_index: int = 0
    ):
        self.name = name
        self.target_qubits = target_qubits
        self.control_qubits = control_qubits or []
        self.parameters = parameters or []
        self.gate_index = gate_index
    
    def __repr__(self) -> str:
        parts = [f"QuantumGate('{self.name}'"]
        parts.append(f"targets={self.target_qubits}")
        if self.control_qubits:
            parts.append(f"controls={self.control_qubits}")
        if self.parameters:
            parts.append(f"params={[f'{p:.4f}' for p in self.parameters]}")
        parts.append(f"idx={self.gate_index}")
        return ", ".join(parts) + ")"
    
    @property
    def is_controlled(self) -> bool:
        """Returns True if this is a controlled gate."""
        return len(self.control_qubits) > 0
    
    @property
    def is_parametric(self) -> bool:
        """Returns True if this gate has parameters."""
        return len(self.parameters) > 0
    
    @property
    def num_qubits_involved(self) -> int:
        """Returns the total number of qubits this gate acts on."""
        return len(self.target_qubits) + len(self.control_qubits)


class MLIRCircuitParser:
    """
    Parser for extracting quantum circuit topology from CUDA-Q MLIR IR.
    
    This parser reads the MLIR intermediate representation (Quake dialect) 
    generated by CUDA-Q and extracts the complete circuit topology, including
    gate types, target qubits, control qubits, and parameters.
    
    Supported Gates:
        Single-qubit: h, x, y, z, s, t, sdg, tdg
        Rotations: rx, ry, rz, r1
        Two-qubit: cx (CNOT), cy, cz, swap, ccx (Toffoli)
    
    Examples:
        >>> parser = MLIRCircuitParser()
        >>> gates, num_qubits = parser.parse_kernel(my_kernel)
        >>> for gate in gates:
        ...     print(f"{gate.name} on qubits {gate.target_qubits}")
    """
    
    def __init__(self):
        self._qubit_mapping: Dict[str, int] = {}
        self._num_qubits: int = 0
        self._unsupported_ops: set = set()
        
        # Pre-compiled regex patterns for efficiency
        self._patterns = {
            'alloca': re.compile(r'quake\.alloca !quake\.veq<(\d+)>'),
            'extract': re.compile(r'%(\w+) = quake\.extract_ref %\w+\[(\d+)\]'),
            'single_qubit': re.compile(r'quake\.(h|x|y|z|s|t|sdg|tdg)\s+%(\w+)'),
            'rotation': re.compile(r'quake\.(rx|ry|rz|r1)\s*\(([^)]+)\)\s+%(\w+)'),
            'controlled': re.compile(r'quake\.(x|y|z)\s+\[([^\]]+)\]\s+%(\w+)'),
            'swap': re.compile(r'quake\.swap\s+%(\w+),\s*%(\w+)'),
            'quake_op': re.compile(r'quake\.(\w+)'),
            # Loop patterns
            'constant_i64': re.compile(r'%([a-z0-9_]+) = arith\.constant (\d+) : i64'),
            'loop_start': re.compile(r'%\w+ = cc\.loop while \(\(%arg\d+ = %([a-z0-9_]+)\)'),
            'loop_condition': re.compile(r'arith\.cmpi slt, %arg\d+, %([a-z0-9_]+)'),
            'loop_step': re.compile(r'arith\.addi %arg\d+, %([a-z0-9_]+)'),
        }
    
    def parse_kernel(self, kernel) -> Tuple[List[QuantumGate], int]:
        """
        Parse a CUDA-Q kernel and extract circuit topology.
        
        Args:
            kernel: A @cudaq.kernel decorated function
            
        Returns:
            Tuple of (gates, num_qubits) where:
                - gates: List of QuantumGate objects in execution order
                - num_qubits: Total number of qubits in the circuit
        
        Examples:
            >>> @cudaq.kernel
            >>> def circuit():
            ...     q = cudaq.qvector(2)
            ...     h(q[0])
            ...     cx(q[0], q[1])
            >>> 
            >>> parser = MLIRCircuitParser()
            >>> gates, n = parser.parse_kernel(circuit)
            >>> assert len(gates) == 2
            >>> assert gates[0].name == 'h'
            >>> assert gates[1].name == 'cx'
        """
        # Reset parser state
        self._qubit_mapping = {}
        self._num_qubits = 0
        
        # Get MLIR IR string representation
        mlir_ir = str(kernel)
        
        # Extract qubit allocation and mapping
        self._extract_qubit_info(mlir_ir)
        
        # Parse all gates
        gates = self._parse_gates(mlir_ir)
        
        return gates, self._num_qubits
    
    def _extract_qubit_info(self, mlir_ir: str) -> None:
        """
        Extract qubit allocation and reference mapping from MLIR IR.

        MLIR format:
            %0 = quake.alloca !quake.veq<N>  # Allocate N qubits
            %1 = quake.extract_ref %0[0]     # %1 refers to qubit 0
            %2 = quake.extract_ref %0[1]     # %2 refers to qubit 1

        Also handles dynamic extraction from loops:
            %2 = quake.extract_ref %0[%arg0] # Dynamic qubit index
        """
        # Find number of qubits from allocation using pre-compiled pattern
        match = self._patterns['alloca'].search(mlir_ir)
        if match:
            self._num_qubits = int(match.group(1))

        # Extract qubit reference mappings using pre-compiled pattern
        for match in self._patterns['extract'].finditer(mlir_ir):
            ref_name = match.group(1)
            qubit_index = int(match.group(2))
            self._qubit_mapping[ref_name] = qubit_index

        # Also extract dynamic references from loops (these won't have fixed indices)
        # Pattern: %2 = quake.extract_ref %0[%arg0]
        dynamic_pattern = re.compile(r'%(\w+) = quake\.extract_ref %\w+\[%arg\d+\]')
        for match in dynamic_pattern.finditer(mlir_ir):
            ref_name = match.group(1)
            # Mark as dynamic with special sentinel value -1
            # We'll handle these gates during loop unrolling
            self._qubit_mapping[ref_name] = -1
    
    def _parse_gates(self, mlir_ir: str) -> List[QuantumGate]:
        """Parse all gate operations from MLIR IR, including those in loops."""
        gates = []
        gate_index = 0

        # IMPORTANT: We need to parse gates in the order CUDA-Q sees them in MLIR
        # Loops are treated as single "gate blocks" by CUDA-Q, so we expand them here
        # but track their original position for tensor extraction

        # First, extract constant definitions for loop bounds
        constants = self._extract_constants(mlir_ir)

        # Parse all gates including loops (expanded in-place)
        lines = mlir_ir.split('\n')
        i = 0
        while i < len(lines):
            line = lines[i].strip()

            # Check if this is a loop construct
            if 'cc.loop' in line:
                # Parse and unroll the loop
                loop_gates, loop_end_idx = self._parse_single_loop(mlir_ir, i, constants)
                gates.extend(loop_gates)
                gate_index += len(loop_gates)
                i = loop_end_idx
                continue

            gate = self._parse_gate(line, gate_index)

            if gate:
                gates.append(gate)
                gate_index += 1
            else:
                # Check if this line contains an unsupported quake operation
                self._check_unsupported_operation(line)

            i += 1

        # Warn about unsupported operations if any were found
        if self._unsupported_ops:
            warnings.warn(
                f"Unsupported quake operations detected: {', '.join(sorted(self._unsupported_ops))}. "
                "These operations were skipped during parsing.",
                UserWarning
            )

        return gates
    
    def _check_unsupported_operation(self, line: str) -> None:
        """Check if line contains an unsupported quake operation and log it."""
        match = self._patterns['quake_op'].search(line)
        if match:
            op_name = match.group(1)
            # Filter out known operations and non-gate operations
            known_ops = {'alloca', 'extract_ref', 'h', 'x', 'y', 'z', 's', 't',
                        'sdg', 'tdg', 'rx', 'ry', 'rz', 'r1', 'swap'}
            if op_name not in known_ops and not op_name.startswith('_'):
                self._unsupported_ops.add(op_name)

    def _extract_constants(self, mlir_ir: str) -> Dict[str, int]:
        """
        Extract constant i64 definitions from MLIR.

        Example: %c0_i64 = arith.constant 0 : i64
        Returns: {'c0_i64': 0, 'c1_i64': 1, 'c4_i64': 4}
        """
        constants = {}
        for match in self._patterns['constant_i64'].finditer(mlir_ir):
            const_name = match.group(1)
            const_value = int(match.group(2))
            constants[const_name] = const_value
        return constants

    def _parse_single_loop(self, mlir_ir: str, start_line_idx: int, constants: Dict[str, int]) -> Tuple[List[QuantumGate], int]:
        """
        Parse a single cc.loop construct starting at start_line_idx and unroll it.

        Returns:
            (list_of_gates, end_line_index)
        """
        gates = []
        lines = mlir_ir.split('\n')

        # Check for loop start
        loop_start_match = self._patterns['loop_start'].search(lines[start_line_idx])
        if not loop_start_match:
            return [], start_line_idx + 1

        start_const = loop_start_match.group(1)
        loop_start_val = constants.get(start_const, 0)

        # Find loop condition (upper bound), step, and do block
        loop_end_val = None
        loop_step_val = None
        do_block_start = None

        j = start_line_idx + 1
        while j < len(lines):
            # Look for condition (upper bound)
            cond_match = self._patterns['loop_condition'].search(lines[j])
            if cond_match:
                end_const = cond_match.group(1)
                loop_end_val = constants.get(end_const, self._num_qubits)

            # Look for step increment
            step_match = self._patterns['loop_step'].search(lines[j])
            if step_match:
                step_const = step_match.group(1)
                loop_step_val = constants.get(step_const, 1)

            # Find do block
            if '} do {' in lines[j]:
                do_block_start = j + 1
                break

            j += 1

        # Extract gates from do block
        if do_block_start is None or loop_end_val is None:
            # Can't parse this loop, skip it
            # Find end of loop structure
            brace_count = 1
            k = start_line_idx + 1
            while k < len(lines) and brace_count > 0:
                brace_count += lines[k].count('{') - lines[k].count('}')
                k += 1
            return [], k

        if loop_step_val is None:
            loop_step_val = 1

        # Find end of do block
        do_block_end = do_block_start
        while do_block_end < len(lines):
            if '} step {' in lines[do_block_end]:
                break
            do_block_end += 1

        # Extract gate operations from do block
        do_block_lines = lines[do_block_start:do_block_end]
        loop_body_gates = []

        for loop_line in do_block_lines:
            loop_line = loop_line.strip()
            # Extract gates (h, x, y, z, etc.)
            for gate_type in ['h', 'x', 'y', 'z', 's', 't', 'sdg', 'tdg']:
                if f'quake.{gate_type} %' in loop_line:
                    loop_body_gates.append(gate_type)
                    break

            # Also check for rotation gates
            for gate_type in ['rx', 'ry', 'rz', 'r1']:
                if f'quake.{gate_type}(' in loop_line:
                    loop_body_gates.append(gate_type)
                    break

        # Unroll loop: create gate instances for each iteration
        gate_idx = 0
        for iteration in range(loop_start_val, loop_end_val, loop_step_val):
            for gate_name in loop_body_gates:
                gate = QuantumGate(
                    name=gate_name,
                    target_qubits=[iteration],
                    gate_index=gate_idx
                )
                gates.append(gate)
                gate_idx += 1

        # Find end of entire loop structure
        # We need to skip past the step block and the final closing brace
        loop_end_line = do_block_end
        # Skip past "} step {" line
        while loop_end_line < len(lines) and '} step {' not in lines[loop_end_line]:
            loop_end_line += 1

        # Now skip the step block content
        if loop_end_line < len(lines):
            loop_end_line += 1  # Move past "} step {" line
            # Find the closing brace of step block and the entire loop
            brace_depth = 0
            while loop_end_line < len(lines):
                line = lines[loop_end_line]
                # Count opening/closing braces
                for char in line:
                    if char == '{':
                        brace_depth += 1
                    elif char == '}':
                        brace_depth -= 1
                        if brace_depth < 0:
                            # Found the final closing brace of the loop
                            return gates, loop_end_line + 1
                loop_end_line += 1

        return gates, loop_end_line

    def _parse_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Unified gate parsing method for a single line of MLIR IR.
        
        This method attempts to match the line against all supported gate patterns
        in order of complexity (controlled gates first, then rotations, etc.).
        
        Args:
            line: A single line from MLIR IR
            gate_index: Index of this gate in the circuit
            
        Returns:
            QuantumGate object if a gate was parsed, None otherwise
        """
        # Try controlled gates first (most specific pattern)
        gate = self._parse_controlled_gate(line, gate_index)
        if gate:
            return gate
        
        # Try rotation gates
        gate = self._parse_rotation_gate(line, gate_index)
        if gate:
            return gate
        
        # Try single-qubit gates
        gate = self._parse_single_qubit_gate(line, gate_index)
        if gate:
            return gate
        
        # Try swap gate
        gate = self._parse_swap_gate(line, gate_index)
        if gate:
            return gate
        
        return None
    
    def _parse_single_qubit_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse single-qubit gates using pre-compiled regex.
        
        MLIR format: quake.h %1 : (!quake.ref) -> ()
        """
        match = self._patterns['single_qubit'].search(line)
        if match:
            gate_name = match.group(1)
            ref = match.group(2)
            if ref in self._qubit_mapping:
                return QuantumGate(
                    name=gate_name,
                    target_qubits=[self._qubit_mapping[ref]],
                    gate_index=gate_index
                )
        
        return None
    
    def _parse_rotation_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse rotation gates using pre-compiled regex.
        
        MLIR format: quake.rz(1.570796) %1 : (f64, !quake.ref) -> ()
        
        Note: If the parameter is a kernel argument (e.g., %arg0), it will be
        set to 0.0 as a placeholder since the actual value is runtime-dependent.
        """
        match = self._patterns['rotation'].search(line)
        if match:
            gate_name = match.group(1)
            param_str = match.group(2)
            ref = match.group(3)
            
            # Parse parameter (may be a constant or variable reference)
            try:
                # Try to parse as float constant
                param = float(param_str.strip('%').strip())
            except ValueError:
                # If it's a variable reference (e.g., %arg0), use 0.0 as placeholder
                param = 0.0
            
            if ref in self._qubit_mapping:
                return QuantumGate(
                    name=gate_name,
                    target_qubits=[self._qubit_mapping[ref]],
                    parameters=[param],
                    gate_index=gate_index
                )
        
        return None
    
    def _parse_controlled_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse controlled gates using pre-compiled regex.
        
        MLIR formats:
            Single control: quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
            Multi-control:  quake.x [%1, %2] %3 : (!quake.ref, !quake.ref, !quake.ref) -> ()
        
        Supports: CX (CNOT), CY, CZ, and multi-controlled versions (e.g., Toffoli/CCX)
        """
        match = self._patterns['controlled'].search(line)
        if match:
            quake_name = match.group(1)  # 'x', 'y', or 'z'
            control_refs_str = match.group(2)  # e.g., "%1" or "%1, %2"
            target_ref = match.group(3)
            
            # Parse control qubits (may be multiple, separated by commas)
            control_refs = [ref.strip().strip('%') for ref in control_refs_str.split(',')]
            
            # Map references to qubit indices
            control_qubits = []
            for ref in control_refs:
                if ref not in self._qubit_mapping:
                    return None  # Invalid reference
                control_qubits.append(self._qubit_mapping[ref])
            
            # Check if target is valid
            if target_ref not in self._qubit_mapping:
                return None
            
            # Determine gate name based on number of controls
            num_controls = len(control_qubits)
            if num_controls == 1:
                gate_name = {'x': 'cx', 'y': 'cy', 'z': 'cz'}[quake_name]
            elif num_controls == 2 and quake_name == 'x':
                gate_name = 'ccx'  # Toffoli gate
            else:
                # For other multi-controlled gates, use descriptive names
                gate_name = f"c{'c' * (num_controls - 1)}{quake_name}"
            
            return QuantumGate(
                name=gate_name,
                target_qubits=[self._qubit_mapping[target_ref]],
                control_qubits=control_qubits,
                gate_index=gate_index
            )
        
        return None
    
    def _parse_swap_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse SWAP gate using pre-compiled regex.
        
        MLIR format: quake.swap %1, %2 : (!quake.ref, !quake.ref) -> ()
        """
        match = self._patterns['swap'].search(line)
        if match:
            ref1 = match.group(1)
            ref2 = match.group(2)
            
            if ref1 in self._qubit_mapping and ref2 in self._qubit_mapping:
                return QuantumGate(
                    name='swap',
                    target_qubits=[
                        self._qubit_mapping[ref1], 
                        self._qubit_mapping[ref2]
                    ],
                    gate_index=gate_index
                )
        
        return None


# ============================================================================
# Helper Functions
# ============================================================================

def _get_state_and_topology(kernel, state=None) -> Tuple[Any, List[QuantumGate], int]:
    """
    Helper function to get CUDA-Q state and parse topology.
    
    This eliminates code duplication in get_circuit_tensors and create_pytorch_converter.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        
    Returns:
        Tuple of (state, gates, num_qubits)
    """
    # Parse topology
    gates, num_qubits = parse_circuit_topology(kernel)
    
    # Get CUDA-Q state if not provided
    if state is None:
        state = cudaq.get_state(kernel)
    
    return state, gates, num_qubits


def _try_import_formotensor_bridge():
    """
    Attempt to import formotensor_bridge module.
    
    Provides helpful error message if module is not found.
    
    Returns:
        The formotensor_bridge module
        
    Raises:
        ImportError: If module cannot be imported with helpful instructions
    """
    try:
        import formotensor_bridge
        return formotensor_bridge
    except ImportError as e:
        raise ImportError(
            "Could not import 'formotensor_bridge' module. "
            "Please ensure it is built and in your PYTHON PATH.\n\n"
            "To build the module:\n"
            "  1. cd /path/to/FormoTensor/build/python\n"
            "  2. cmake ../../python\n"
            "  3. make -j$(nproc)\n\n"
            "To add to PYTHONPATH:\n"
            "  export PYTHONPATH=/path/to/FormoTensor/build/python:$PYTHONPATH\n\n"
            "Or install FormoTensor as a package (recommended):\n"
            "  pip install -e /path/to/FormoTensor\n"
        ) from e


def _try_import_converter():
    """
    Attempt to import CudaqToTorchConverter.
    
    Provides helpful error message if module is not found.
    
    Returns:
        The CudaqToTorchConverter class
        
    Raises:
        ImportError: If module cannot be imported with helpful instructions
    """
    try:
        from cudaq_to_torch_converter import CudaqToTorchConverter
        return CudaqToTorchConverter
    except ImportError as e:
        raise ImportError(
            "Could not import 'cudaq_to_torch_converter' module. "
            "Please ensure it is in your PYTHONPATH.\n\n"
            "To add to PYTHONPATH:\n"
            "  export PYTHONPATH=/path/to/FormoTensor/scripts:$PYTHONPATH\n\n"
            "Or install FormoTensor as a package (recommended):\n"
            "  pip install -e /path/to/FormoTensor\n"
        ) from e


# ============================================================================
# High-level API Functions
# ============================================================================

def parse_circuit_topology(kernel) -> Tuple[List[QuantumGate], int]:
    """
    Parse quantum circuit topology from a CUDA-Q kernel.
    
    This is the main entry point for extracting circuit topology.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        
    Returns:
        Tuple of (gates, num_qubits):
            - gates: List of QuantumGate objects in execution order
            - num_qubits: Total number of qubits in the circuit
    
    Examples:
        >>> @cudaq.kernel
        >>> def bell_state():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> gates, n_qubits = parse_circuit_topology(bell_state)
        >>> print(f"Circuit has {n_qubits} qubits and {len(gates)} gates")
        Circuit has 2 qubits and 2 gates
    """
    parser = MLIRCircuitParser()
    return parser.parse_kernel(kernel)


def print_circuit_topology(kernel) -> None:
    """
    Print a human-readable representation of circuit topology.
    
    Args:
        kernel: A @cudaq.kernel decorated function
    
    Examples:
        >>> @cudaq.kernel
        >>> def my_circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> print_circuit_topology(my_circuit)
        Circuit: 2 qubits, 2 gates
        ================================================================
        Gate 0: H
          Targets: [0]
        Gate 1: CX
          Targets: [1]
          Controls: [0]
        ================================================================
    """
    gates, num_qubits = parse_circuit_topology(kernel)
    
    print(f"Circuit: {num_qubits} qubits, {len(gates)} gates")
    print("=" * 64)
    
    for gate in gates:
        print(f"Gate {gate.gate_index}: {gate.name.upper()}")
        print(f"  Targets: {gate.target_qubits}")
        if gate.control_qubits:
            print(f"  Controls: {gate.control_qubits}")
        if gate.parameters:
            print(f"  Parameters: {gate.parameters}")
    
    print("=" * 64)


def get_circuit_tensors(kernel, state=None, return_metadata=False):
    """
    Extract circuit gate tensors as PyTorch tensors with topology metadata.
    
    This function extracts both the tensor data and topology information,
    returning them in a format suitable for quantum machine learning applications.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        return_metadata: If True, returns additional metadata
        
    Returns:
        If return_metadata=False (default):
            Tuple of (tensors, topology):
                - tensors: List of torch.Tensor objects (one per gate)
                - topology: List of QuantumGate objects
        
        If return_metadata=True:
            Dict with keys:
                - 'tensors': List of torch.Tensor objects
                - 'gates': List of QuantumGate objects
                - 'num_qubits': Total number of qubits
                - 'num_gates': Total number of gates
                - 'circuit_depth': Maximum circuit depth
    
    Examples:
        >>> @cudaq.kernel
        >>> def circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> tensors, gates = get_circuit_tensors(circuit)
        >>> print(f"H gate tensor shape: {tensors[0].shape}")
        H gate tensor shape: torch.Size([2, 2])
        >>> print(f"CNOT gate tensor shape: {tensors[1].shape}")
        CNOT gate tensor shape: torch.Size([2, 2, 2, 2])
        
        >>> # With metadata
        >>> data = get_circuit_tensors(circuit, return_metadata=True)
        >>> print(f"Circuit has {data['num_qubits']} qubits")
        Circuit has 2 qubits
    """
    # Import formotensor_bridge with helpful error messages
    ftb = _try_import_formotensor_bridge()
    
    # Get state and topology (using helper to avoid duplication)
    state, gates, num_qubits = _get_state_and_topology(kernel, state)
    
    # Extract tensors
    tensors = []
    for i, gate in enumerate(gates):
        tensor = ftb.TensorNetworkHelper.extract_tensor_data(state, i)
        tensors.append(tensor)
    
    if not return_metadata:
        return tensors, gates
    
    # Calculate circuit depth
    qubit_depths = [0] * num_qubits
    for gate in gates:
        involved_qubits = gate.target_qubits + gate.control_qubits
        max_depth = max(qubit_depths[q] for q in involved_qubits)
        for q in involved_qubits:
            qubit_depths[q] = max_depth + 1
    
    circuit_depth = max(qubit_depths) if qubit_depths else 0
    
    return {
        'tensors': tensors,
        'gates': gates,
        'num_qubits': num_qubits,
        'num_gates': len(gates),
        'circuit_depth': circuit_depth
    }


def create_pytorch_converter(kernel, state=None):
    """
    Create a PyTorch-based tensor network converter with automatic topology.
    
    This is the recommended high-level function for converting CUDA-Q circuits
    to PyTorch tensor networks.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        
    Returns:
        A CudaqToTorchConverter instance ready for contraction or manipulation
    
    Examples:
        >>> @cudaq.kernel
        >>> def circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> # Create converter
        >>> converter = create_pytorch_converter(circuit)
        >>> 
        >>> # Contract to get final state
        >>> state_vector = converter.contract()
        >>> print(state_vector.flatten())
        tensor([0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j])
        >>> 
        >>> # Or get einsum expression
        >>> expr, tensors = converter.generate_einsum_expression()
        >>> print(f"Einsum: {expr}")
        Einsum: ca,decb->de
    """
    # Import required modules with helpful error messages
    CudaqToTorchConverter = _try_import_converter()
    ftb = _try_import_formotensor_bridge()
    
    # Get state and topology (using helper to avoid duplication)
    state, gates, num_qubits = _get_state_and_topology(kernel, state)
    
    # Create converter
    converter = CudaqToTorchConverter(num_qubits=num_qubits)
    
    # Add gates with topology
    for i, gate in enumerate(gates):
        tensor = ftb.TensorNetworkHelper.extract_tensor_data(state, i)
        converter.add_gate(
            tensor,
            targets=gate.target_qubits,
            controls=gate.control_qubits,
            name=gate.name
        )
    
    return converter


# Backward compatibility aliases
extract_topology_from_kernel = parse_circuit_topology
print_topology = print_circuit_topology
create_torch_converter_from_kernel = create_pytorch_converter


if __name__ == "__main__":
    # Simple test
    import numpy as np
    
    cudaq.set_target("tensornet")
    
    @cudaq.kernel
    def test_circuit():
        q = cudaq.qvector(2)
        h(q[0])
        cx(q[0], q[1])
    
    print("Testing MLIR Circuit Parser:")
    print_circuit_topology(test_circuit)

