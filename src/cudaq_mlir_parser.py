#!/usr/bin/env python3
"""
CUDA-Q MLIR Parser for Automatic Topology Extraction

This module provides automatic extraction of quantum circuit topology information
from CUDA-Q kernels by parsing their MLIR intermediate representation (Quake dialect).

Key Features:
    - Automatic topology extraction (no manual specification required)
    - Support for all common quantum gates
    - Direct integration with PyTorch for quantum machine learning
    - Production-ready and thoroughly tested

Author: FormoTensor Team
License: Apache 2.0
Repository: https://github.com/yourusername/FormoTensor
"""

import re
import warnings
from typing import List, Dict, Tuple, Optional, Any
import cudaq


class QuantumGate:
    """
    Represents a quantum gate with its topology information.
    
    Attributes:
        name (str): Gate name (e.g., 'h', 'cx', 'rz')
        target_qubits (List[int]): Target qubit indices
        control_qubits (List[int]): Control qubit indices (empty for non-controlled gates)
        parameters (List[float]): Gate parameters (e.g., rotation angles)
        gate_index (int): Position of this gate in the circuit
    
    Examples:
        >>> gate = QuantumGate('h', targets=[0])
        >>> gate = QuantumGate('cx', targets=[1], controls=[0])
        >>> gate = QuantumGate('rz', targets=[0], parameters=[np.pi/4])
    """
    
    def __init__(
        self, 
        name: str, 
        target_qubits: List[int], 
        control_qubits: Optional[List[int]] = None, 
        parameters: Optional[List[float]] = None,
        gate_index: int = 0
    ):
        self.name = name
        self.target_qubits = target_qubits
        self.control_qubits = control_qubits or []
        self.parameters = parameters or []
        self.gate_index = gate_index
    
    def __repr__(self) -> str:
        parts = [f"QuantumGate('{self.name}'"]
        parts.append(f"targets={self.target_qubits}")
        if self.control_qubits:
            parts.append(f"controls={self.control_qubits}")
        if self.parameters:
            parts.append(f"params={[f'{p:.4f}' for p in self.parameters]}")
        parts.append(f"idx={self.gate_index}")
        return ", ".join(parts) + ")"
    
    @property
    def is_controlled(self) -> bool:
        """Returns True if this is a controlled gate."""
        return len(self.control_qubits) > 0
    
    @property
    def is_parametric(self) -> bool:
        """Returns True if this gate has parameters."""
        return len(self.parameters) > 0
    
    @property
    def num_qubits_involved(self) -> int:
        """Returns the total number of qubits this gate acts on."""
        return len(self.target_qubits) + len(self.control_qubits)


class MLIRCircuitParser:
    """
    Parser for extracting quantum circuit topology from CUDA-Q MLIR IR.
    
    This parser reads the MLIR intermediate representation (Quake dialect) 
    generated by CUDA-Q and extracts the complete circuit topology, including
    gate types, target qubits, control qubits, and parameters.
    
    Supported Gates:
        Single-qubit: h, x, y, z, s, t, sdg, tdg
        Rotations: rx, ry, rz, r1
        Two-qubit: cx (CNOT), cy, cz, swap, ccx (Toffoli)
    
    Examples:
        >>> parser = MLIRCircuitParser()
        >>> gates, num_qubits = parser.parse_kernel(my_kernel)
        >>> for gate in gates:
        ...     print(f"{gate.name} on qubits {gate.target_qubits}")
    """
    
    def __init__(self):
        self._qubit_mapping: Dict[str, int] = {}
        self._num_qubits: int = 0
        self._unsupported_ops: set = set()
        
        # Pre-compiled regex patterns for efficiency
        self._patterns = {
            'alloca': re.compile(r'quake\.alloca !quake\.veq<(\d+)>'),
            'alloca_dynamic': re.compile(r'quake\.alloca !quake\.veq<\?>'),
            'extract': re.compile(r'%(\w+) = quake\.extract_ref %\w+\[(\d+)\]'),
            'single_qubit': re.compile(r'quake\.(h|x|y|z|s|t|sdg|tdg)\s+%(\w+)'),
            'rotation': re.compile(r'quake\.(rx|ry|rz|r1)\s*\(([^)]+)\)\s+%(\w+)'),
            'controlled': re.compile(r'quake\.(x|y|z)\s+\[([^\]]+)\]\s+%(\w+)'),
            'swap': re.compile(r'quake\.swap\s+%(\w+),\s*%(\w+)'),
            'quake_op': re.compile(r'quake\.(\w+)'),
            # Loop patterns
            'constant_i64': re.compile(r'%([a-z0-9_-]+) = arith\.constant (-?\d+) : i64'),
            'loop_start': re.compile(r'%\w+ = cc\.loop while \(\(%arg\d+ = %([a-z0-9_-]+)\)'),
            'loop_condition_slt': re.compile(r'arith\.cmpi slt, %arg\d+, %([a-z0-9_-]+)'),
            'loop_condition_sgt': re.compile(r'arith\.cmpi sgt, %arg\d+, %([a-z0-9_-]+)'),
            'loop_step': re.compile(r'arith\.addi %arg\d+, %([a-z0-9_-]+)'),
        }
    
    def parse_kernel(self, kernel) -> Tuple[List[QuantumGate], int]:
        """
        Parse a CUDA-Q kernel and extract circuit topology.
        
        Args:
            kernel: A @cudaq.kernel decorated function
            
        Returns:
            Tuple of (gates, num_qubits) where:
                - gates: List of QuantumGate objects in execution order
                - num_qubits: Total number of qubits in the circuit
        
        Examples:
            >>> @cudaq.kernel
            >>> def circuit():
            ...     q = cudaq.qvector(2)
            ...     h(q[0])
            ...     cx(q[0], q[1])
            >>> 
            >>> parser = MLIRCircuitParser()
            >>> gates, n = parser.parse_kernel(circuit)
            >>> assert len(gates) == 2
            >>> assert gates[0].name == 'h'
            >>> assert gates[1].name == 'cx'
        """
        # Reset parser state
        self._qubit_mapping = {}
        self._num_qubits = 0
        
        # Get MLIR IR string representation
        mlir_ir = str(kernel)
        
        # Extract qubit allocation and mapping
        self._extract_qubit_info(mlir_ir)
        
        # Parse all gates
        gates = self._parse_gates(mlir_ir)

        # Fallback: if num_qubits is still 0 but we have gates, infer from gate qubits
        if self._num_qubits == 0 and gates:
            max_qubit = 0
            for gate in gates:
                all_qubits = gate.target_qubits + gate.control_qubits
                if all_qubits:
                    max_qubit = max(max_qubit, max(all_qubits))
            self._num_qubits = max_qubit + 1

        return gates, self._num_qubits
    
    def _extract_qubit_info(self, mlir_ir: str) -> None:
        """
        Extract qubit allocation and reference mapping from MLIR IR.

        MLIR format:
            %0 = quake.alloca !quake.veq<N>  # Allocate N qubits (fixed)
            %0 = quake.alloca !quake.veq<?>[%n : i64]  # Allocate N qubits (dynamic)
            %1 = quake.extract_ref %0[0]     # %1 refers to qubit 0
            %2 = quake.extract_ref %0[1]     # %2 refers to qubit 1

        Also handles dynamic extraction from loops:
            %2 = quake.extract_ref %0[%arg0] # Dynamic qubit index
        """
        # Find number of qubits from allocation using pre-compiled pattern
        match = self._patterns['alloca'].search(mlir_ir)
        if match:
            self._num_qubits = int(match.group(1))
        elif self._patterns['alloca_dynamic'].search(mlir_ir):
            # Dynamic allocation - try to infer from constants
            # Pattern: %c4_i64 = arith.constant 4 : i64
            #          %0 = cc.alloca i64
            #          cc.store %c4_i64, %0
            #          %1 = cc.load %0
            #          %2 = quake.alloca !quake.veq<?>[%1 : i64]
            # Look for the largest constant that might be the qubit count
            constants = {}
            for m in self._patterns['constant_i64'].finditer(mlir_ir):
                const_name = m.group(1)
                const_value = int(m.group(2))
                constants[const_name] = const_value

            # Find the constant used in alloca (heuristic: look for c<N>_i64 patterns)
            # or use the largest reasonable constant (< 100) as qubit count
            for name, value in constants.items():
                if 1 < value < 100 and name.startswith('c') and name.endswith('_i64'):
                    # This might be the qubit count
                    if value > self._num_qubits:
                        self._num_qubits = value

        # Extract qubit reference mappings using pre-compiled pattern
        for match in self._patterns['extract'].finditer(mlir_ir):
            ref_name = match.group(1)
            qubit_index = int(match.group(2))
            self._qubit_mapping[ref_name] = qubit_index

        # Also extract dynamic references from loops (these won't have fixed indices)
        # Pattern: %2 = quake.extract_ref %0[%arg0]
        dynamic_pattern = re.compile(r'%(\w+) = quake\.extract_ref %\w+\[%arg\d+\]')
        for match in dynamic_pattern.finditer(mlir_ir):
            ref_name = match.group(1)
            # Mark as dynamic with special sentinel value -1
            # We'll handle these gates during loop unrolling
            self._qubit_mapping[ref_name] = -1
    
    def _parse_gates(self, mlir_ir: str) -> List[QuantumGate]:
        """Parse all gate operations from MLIR IR, including those in loops."""
        gates = []
        gate_index = 0

        # IMPORTANT: We need to parse gates in the order CUDA-Q sees them in MLIR
        # Loops are treated as single "gate blocks" by CUDA-Q, so we expand them here
        # but track their original position for tensor extraction

        # First, extract constant definitions for loop bounds
        constants = self._extract_constants(mlir_ir)

        # Parse all gates including loops (expanded in-place)
        lines = mlir_ir.split('\n')
        i = 0
        while i < len(lines):
            line = lines[i].strip()

            # Check if this is a loop construct
            if 'cc.loop' in line:
                # Parse and unroll the loop
                loop_gates, loop_end_idx = self._parse_single_loop(mlir_ir, i, constants)
                gates.extend(loop_gates)
                gate_index += len(loop_gates)
                i = loop_end_idx
                continue

            gate = self._parse_gate(line, gate_index)

            if gate:
                gates.append(gate)
                gate_index += 1
            else:
                # Check if this line contains an unsupported quake operation
                self._check_unsupported_operation(line)

            i += 1

        # Warn about unsupported operations if any were found
        if self._unsupported_ops:
            warnings.warn(
                f"Unsupported quake operations detected: {', '.join(sorted(self._unsupported_ops))}. "
                "These operations were skipped during parsing.",
                UserWarning
            )

        return gates
    
    def _check_unsupported_operation(self, line: str) -> None:
        """Check if line contains an unsupported quake operation and log it."""
        match = self._patterns['quake_op'].search(line)
        if match:
            op_name = match.group(1)
            # Filter out known operations and non-gate operations
            known_ops = {'alloca', 'extract_ref', 'h', 'x', 'y', 'z', 's', 't',
                        'sdg', 'tdg', 'rx', 'ry', 'rz', 'r1', 'swap'}
            if op_name not in known_ops and not op_name.startswith('_'):
                self._unsupported_ops.add(op_name)

    def _extract_constants(self, mlir_ir: str) -> Dict[str, int]:
        """
        Extract constant i64 definitions and computed values from MLIR.

        Example: %c0_i64 = arith.constant 0 : i64
        Returns: {'c0_i64': 0, 'c1_i64': 1, 'c4_i64': 4}

        Also tracks arithmetic operations like:
            %8 = arith.subi %c4_i64, %c1_i64 : i64  -> {'8': 3}
        """
        constants = {}
        # Extract base constants
        for match in self._patterns['constant_i64'].finditer(mlir_ir):
            const_name = match.group(1)
            const_value = int(match.group(2))
            constants[const_name] = const_value

        # Extract computed values from arithmetic operations
        # Pattern: %8 = arith.subi %c4_i64, %c1_i64
        subi_pattern = re.compile(r'%(\w+) = arith\.subi %([a-z0-9_]+), %([a-z0-9_]+)')
        for match in subi_pattern.finditer(mlir_ir):
            result_var = match.group(1)
            left_var = match.group(2)
            right_var = match.group(3)
            if left_var in constants and right_var in constants:
                constants[result_var] = constants[left_var] - constants[right_var]

        return constants

    def _parse_single_loop(self, mlir_ir: str, start_line_idx: int, constants: Dict[str, int]) -> Tuple[List[QuantumGate], int]:
        """
        Parse a single cc.loop construct starting at start_line_idx and unroll it.

        This now supports multi-qubit gates (like CX) by tracking arithmetic operations
        and resolving dynamic qubit indices.

        Returns:
            (list_of_gates, end_line_index)
        """
        gates = []
        lines = mlir_ir.split('\n')

        # Check for loop start
        loop_start_match = self._patterns['loop_start'].search(lines[start_line_idx])
        if not loop_start_match:
            return [], start_line_idx + 1

        start_const = loop_start_match.group(1)
        loop_start_val = constants.get(start_const, 0)

        # Find loop condition (upper/lower bound), step, and do block
        loop_end_val = None
        loop_step_val = None
        do_block_start = None
        is_reverse = False

        j = start_line_idx + 1
        while j < len(lines):
            # Look for condition (check both forward and reverse)
            cond_match_slt = self._patterns['loop_condition_slt'].search(lines[j])
            cond_match_sgt = self._patterns['loop_condition_sgt'].search(lines[j])

            if cond_match_slt:
                # Forward loop: i < end
                end_const = cond_match_slt.group(1)
                loop_end_val = constants.get(end_const, self._num_qubits)
                is_reverse = False
            elif cond_match_sgt:
                # Reverse loop: i > end
                end_const = cond_match_sgt.group(1)
                loop_end_val = constants.get(end_const, -1)
                is_reverse = True

            # Look for step increment
            step_match = self._patterns['loop_step'].search(lines[j])
            if step_match:
                step_const = step_match.group(1)
                loop_step_val = constants.get(step_const, -1 if is_reverse else 1)

            # Find do block
            if '} do {' in lines[j]:
                do_block_start = j + 1
                break

            j += 1

        # Extract gates from do block
        if do_block_start is None or loop_end_val is None:
            # Can't parse this loop, skip it
            # Find end of loop structure
            brace_count = 1
            k = start_line_idx + 1
            while k < len(lines) and brace_count > 0:
                brace_count += lines[k].count('{') - lines[k].count('}')
                k += 1
            return [], k

        if loop_step_val is None:
            loop_step_val = -1 if is_reverse else 1

        # Find end of do block (track brace depth to handle nested loops)
        do_block_end = do_block_start
        brace_depth = 0
        while do_block_end < len(lines):
            line = lines[do_block_end]
            # Track braces to handle nested loops
            brace_depth += line.count('{') - line.count('}')

            # Only stop at '} step {' when we're at the correct nesting level
            if '} step {' in line and brace_depth == 0:
                break
            do_block_end += 1

        # Extract gate operations from do block
        do_block_lines = lines[do_block_start:do_block_end]

        # Parse the loop body to extract gate templates
        loop_body_gates = self._parse_loop_body(do_block_lines, constants)

        # Unroll loop: create gate instances for each iteration
        gate_idx = 0
        for iteration in range(loop_start_val, loop_end_val, loop_step_val):
            iteration_context = {0: iteration}  # arg0 = outer loop iteration

            for gate_template in loop_body_gates:
                # Check if this is a nested loop template
                if gate_template.get('nested_loop'):
                    # Parse nested loop manually for 2-level nesting
                    nested_loop_lines = gate_template['mlir_lines']

                    # Extract nested loop bounds and body
                    nested_info = self._parse_nested_loop_simple(nested_loop_lines, constants)
                    if nested_info:
                        inner_start, inner_end, inner_step, inner_body_gates = nested_info

                        # Double unroll: outer × inner iterations
                        for inner_iteration in range(inner_start, inner_end, inner_step):
                            inner_context = {0: iteration, 1: inner_iteration}  # arg0=i, arg1=j

                            for inner_gate_template in inner_body_gates:
                                target_qubits = [self._resolve_loop_index(idx, iteration, inner_context)
                                               for idx in inner_gate_template['targets']]
                                control_qubits = [self._resolve_loop_index(idx, iteration, inner_context)
                                                for idx in inner_gate_template.get('controls', [])]

                                gate = QuantumGate(
                                    name=inner_gate_template['name'],
                                    target_qubits=target_qubits,
                                    control_qubits=control_qubits,
                                    parameters=inner_gate_template.get('parameters', []),
                                    gate_index=gate_idx
                                )
                                gates.append(gate)
                                gate_idx += 1
                    continue

                # Normal gate template - resolve qubit indices
                target_qubits = [self._resolve_loop_index(idx, iteration, iteration_context) for idx in gate_template['targets']]
                control_qubits = [self._resolve_loop_index(idx, iteration, iteration_context) for idx in gate_template.get('controls', [])]

                gate = QuantumGate(
                    name=gate_template['name'],
                    target_qubits=target_qubits,
                    control_qubits=control_qubits,
                    parameters=gate_template.get('parameters', []),
                    gate_index=gate_idx
                )
                gates.append(gate)
                gate_idx += 1

        # Find end of entire loop structure
        # We need to skip past the step block and the final closing brace
        loop_end_line = do_block_end
        # Skip past "} step {" line
        while loop_end_line < len(lines) and '} step {' not in lines[loop_end_line]:
            loop_end_line += 1

        # Now skip the step block content
        if loop_end_line < len(lines):
            loop_end_line += 1  # Move past "} step {" line
            # Find the closing brace of step block and the entire loop
            brace_depth = 0
            while loop_end_line < len(lines):
                line = lines[loop_end_line]
                # Count opening/closing braces
                for char in line:
                    if char == '{':
                        brace_depth += 1
                    elif char == '}':
                        brace_depth -= 1
                        if brace_depth < 0:
                            # Found the final closing brace of the loop
                            return gates, loop_end_line + 1
                loop_end_line += 1

        return gates, loop_end_line

    def _parse_nested_loop_simple(self, nested_loop_lines: List[str], constants: Dict[str, int]) -> Optional[Tuple[int, int, int, List[Dict]]]:
        """
        Simple parser for nested loops (2-level nesting only).

        Returns:
            (start_val, end_val, step_val, gate_templates) or None if parsing fails
        """
        # Find loop start value
        start_match = self._patterns['loop_start'].search(nested_loop_lines[0])
        if not start_match:
            return None
        start_val = constants.get(start_match.group(1), 0)

        # Find loop condition (end value)
        end_val = None
        step_val = None
        do_block_start = None
        is_reverse = False

        for i, line in enumerate(nested_loop_lines):
            # Look for condition (check both forward and reverse)
            cond_match_slt = self._patterns['loop_condition_slt'].search(line)
            cond_match_sgt = self._patterns['loop_condition_sgt'].search(line)

            if cond_match_slt:
                end_val = constants.get(cond_match_slt.group(1), self._num_qubits)
                is_reverse = False
            elif cond_match_sgt:
                end_val = constants.get(cond_match_sgt.group(1), -1)
                is_reverse = True

            # Look for step
            step_match = self._patterns['loop_step'].search(line)
            if step_match:
                step_val = constants.get(step_match.group(1), -1 if is_reverse else 1)

            # Find do block
            if '} do {' in line:
                do_block_start = i + 1
                break

        if end_val is None or do_block_start is None:
            return None

        if step_val is None:
            step_val = -1 if is_reverse else 1

        # Find end of do block
        do_block_end = do_block_start
        for i in range(do_block_start, len(nested_loop_lines)):
            if '} step {' in nested_loop_lines[i]:
                do_block_end = i
                break

        # Extract gate templates from do block
        do_block = nested_loop_lines[do_block_start:do_block_end]
        gate_templates = self._parse_loop_body(do_block, constants)

        return (start_val, end_val, step_val, gate_templates)

    def _parse_loop_body(self, do_block_lines: List[str], constants: Dict[str, int]) -> List[Dict]:
        """
        Parse the loop body to extract gate templates with symbolic qubit indices.

        This method tracks arithmetic operations and resolves qubit references to
        handle multi-qubit gates like CX in loops. Now supports nested loops.

        Returns:
            List of gate templates, each a dict with:
                - 'name': gate name
                - 'targets': list of symbolic indices (e.g., [('arg', 0)] for %arg0)
                - 'controls': list of symbolic indices for controlled gates
                - 'parameters': list of parameter values for rotation gates
                - 'nested_loop': for nested loops, contains the loop structure
        """
        gate_templates = []

        # Symbol table: maps variable names to their symbolic values
        # E.g., '%3' -> ('arg', 1) means %3 = %arg0 + 1
        # E.g., '%3' -> ('mul', 0, 2) means %3 = %arg0 * 2
        symbols = {}

        # Track qubit extractions: maps ref names to their symbolic indices
        # E.g., '%2' -> ('arg', 0) means %2 = extract_ref[%arg0]
        qubit_refs = {}

        i = 0
        while i < len(do_block_lines):
            line = do_block_lines[i].strip()

            # Check for nested loop
            if 'cc.loop while' in line:
                # Found a nested loop - extract its MLIR text for recursive parsing
                # We need to extract the complete cc.loop structure including while/do/step blocks
                nested_loop_lines = [line]
                brace_count = line.count('{') - line.count('}')

                i += 1
                # Continue until we've closed all braces from the cc.loop structure
                while i < len(do_block_lines):
                    nested_loop_lines.append(do_block_lines[i])
                    brace_count += do_block_lines[i].count('{') - do_block_lines[i].count('}')
                    i += 1
                    # Stop when braces are balanced (loop structure complete)
                    if brace_count == 0:
                        break

                # Store nested loop template with the MLIR text
                gate_templates.append({
                    'nested_loop': True,
                    'mlir_lines': nested_loop_lines
                })
                continue

            # Parse multiplication: %3 = arith.muli %arg0, %c2_i64
            muli_match = re.match(r'%(\w+) = arith\.muli %arg(\d+), %([a-z0-9_]+)', line)
            if muli_match:
                result_var = muli_match.group(1)
                arg_num = int(muli_match.group(2))
                mult_const = muli_match.group(3)
                mult_val = constants.get(mult_const, 1)
                # Store symbolic value: result = arg * multiplier
                symbols[result_var] = ('mul', arg_num, mult_val)
                i += 1
                continue

            # Parse addition with variable: %4 = arith.addi %3, %arg1
            addi_var_arg_match = re.match(r'%(\w+) = arith\.addi %(\w+), %arg(\d+)', line)
            if addi_var_arg_match:
                result_var = addi_var_arg_match.group(1)
                left_var = addi_var_arg_match.group(2)
                arg_num = int(addi_var_arg_match.group(3))
                if left_var in symbols:
                    # Combine: if left_var is ('mul', 0, 2) and we're adding arg1,
                    # result is ('mul_add', 0, 2, 1, 0) meaning arg0*2 + arg1*1 + 0
                    symbols[result_var] = ('add_arg', symbols[left_var], arg_num)
                i += 1
                continue

            # Parse arithmetic operations: %3 = arith.addi %arg0, %c1_i64
            arith_match = re.match(r'%(\w+) = arith\.addi %arg(\d+), %([a-z0-9_]+)', line)
            if arith_match:
                result_var = arith_match.group(1)
                arg_num = int(arith_match.group(2))
                offset_const = arith_match.group(3)
                offset_val = constants.get(offset_const, 1)
                # Store symbolic value: result = arg + offset
                symbols[result_var] = ('arg', arg_num, offset_val)
                i += 1
                continue

            # Parse qubit extractions with loop variable: %2 = quake.extract_ref %0[%arg0]
            extract_arg_match = re.match(r'%(\w+) = quake\.extract_ref %\w+\[%arg(\d+)\]', line)
            if extract_arg_match:
                ref_name = extract_arg_match.group(1)
                arg_num = int(extract_arg_match.group(2))
                qubit_refs[ref_name] = ('arg', arg_num, 0)  # Direct loop variable, offset 0
                i += 1
                continue

            # Parse qubit extractions with computed variable: %4 = quake.extract_ref %0[%3]
            extract_var_match = re.match(r'%(\w+) = quake\.extract_ref %\w+\[%(\w+)\]', line)
            if extract_var_match:
                ref_name = extract_var_match.group(1)
                var_name = extract_var_match.group(2)
                if var_name in symbols:
                    qubit_refs[ref_name] = symbols[var_name]
                i += 1
                continue

            # Parse single-qubit gates: quake.h %2
            single_match = re.match(r'quake\.(h|x|y|z|s|t|sdg|tdg)\s+%(\w+)', line)
            if single_match:
                gate_name = single_match.group(1)
                ref = single_match.group(2)
                if ref in qubit_refs:
                    gate_templates.append({
                        'name': gate_name,
                        'targets': [qubit_refs[ref]]
                    })
                i += 1
                continue

            # Parse rotation gates: quake.rz(0.5) %2
            rotation_match = re.match(r'quake\.(rx|ry|rz|r1)\s*\(([^)]+)\)\s+%(\w+)', line)
            if rotation_match:
                gate_name = rotation_match.group(1)
                param_str = rotation_match.group(2)
                ref = rotation_match.group(3)

                # Parse parameter
                try:
                    param = float(param_str.strip('%').strip())
                except ValueError:
                    param = 0.0  # Placeholder for variable parameters

                if ref in qubit_refs:
                    gate_templates.append({
                        'name': gate_name,
                        'targets': [qubit_refs[ref]],
                        'parameters': [param]
                    })
                i += 1
                continue

            # Parse controlled gates: quake.x [%2] %4
            controlled_match = re.match(r'quake\.(x|y|z)\s+\[([^\]]+)\]\s+%(\w+)', line)
            if controlled_match:
                quake_name = controlled_match.group(1)
                control_refs_str = controlled_match.group(2)
                target_ref = controlled_match.group(3)

                # Parse control qubits
                control_refs = [ref.strip().strip('%') for ref in control_refs_str.split(',')]
                control_indices = []
                for ref in control_refs:
                    if ref in qubit_refs:
                        control_indices.append(qubit_refs[ref])

                # Parse target qubit
                target_index = None
                if target_ref in qubit_refs:
                    target_index = qubit_refs[target_ref]

                # Create gate template if all refs resolved
                if control_indices and target_index:
                    # Determine gate name
                    num_controls = len(control_indices)
                    if num_controls == 1:
                        gate_name = {'x': 'cx', 'y': 'cy', 'z': 'cz'}[quake_name]
                    elif num_controls == 2 and quake_name == 'x':
                        gate_name = 'ccx'
                    else:
                        gate_name = f"c{'c' * (num_controls - 1)}{quake_name}"

                    gate_templates.append({
                        'name': gate_name,
                        'targets': [target_index],
                        'controls': control_indices
                    })
                i += 1
                continue

            # If we reach here, this line wasn't processed
            i += 1

        return gate_templates

    def _resolve_loop_index(self, symbolic_idx: Tuple, iteration: int, iteration_context: dict = None) -> int:
        """
        Resolve a symbolic index to an actual qubit index for a given loop iteration.

        Args:
            symbolic_idx: Symbolic index representation:
                - ('arg', offset) - simple: loop_var + offset (for backward compat)
                - ('arg', arg_num, offset) - multi-arg: arg[arg_num] + offset
                - ('mul', arg_num, multiplier) - multiplication: arg[arg_num] * multiplier
                - ('add_arg', base_symbol, arg_num) - addition: base_symbol + arg[arg_num]
            iteration: Current loop iteration value (for single loops)
            iteration_context: Dict mapping arg_num to iteration values (for nested loops)

        Returns:
            Actual qubit index
        """
        if iteration_context is None:
            iteration_context = {0: iteration}  # Default: arg0 = iteration

        idx_type = symbolic_idx[0]

        if idx_type == 'arg':
            if len(symbolic_idx) == 2:
                # Old format: ('arg', offset)
                return iteration + symbolic_idx[1]
            else:
                # New format: ('arg', arg_num, offset)
                arg_num = symbolic_idx[1]
                offset = symbolic_idx[2]
                return iteration_context.get(arg_num, iteration) + offset

        elif idx_type == 'mul':
            # ('mul', arg_num, multiplier)
            arg_num = symbolic_idx[1]
            multiplier = symbolic_idx[2]
            return iteration_context.get(arg_num, iteration) * multiplier

        elif idx_type == 'add_arg':
            # ('add_arg', base_symbol, arg_num)
            base_symbol = symbolic_idx[1]
            arg_num = symbolic_idx[2]
            base_value = self._resolve_loop_index(base_symbol, iteration, iteration_context)
            return base_value + iteration_context.get(arg_num, 0)

        return 0  # Fallback

    def _parse_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Unified gate parsing method for a single line of MLIR IR.
        
        This method attempts to match the line against all supported gate patterns
        in order of complexity (controlled gates first, then rotations, etc.).
        
        Args:
            line: A single line from MLIR IR
            gate_index: Index of this gate in the circuit
            
        Returns:
            QuantumGate object if a gate was parsed, None otherwise
        """
        # Try controlled gates first (most specific pattern)
        gate = self._parse_controlled_gate(line, gate_index)
        if gate:
            return gate
        
        # Try rotation gates
        gate = self._parse_rotation_gate(line, gate_index)
        if gate:
            return gate
        
        # Try single-qubit gates
        gate = self._parse_single_qubit_gate(line, gate_index)
        if gate:
            return gate
        
        # Try swap gate
        gate = self._parse_swap_gate(line, gate_index)
        if gate:
            return gate
        
        return None
    
    def _parse_single_qubit_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse single-qubit gates using pre-compiled regex.
        
        MLIR format: quake.h %1 : (!quake.ref) -> ()
        """
        match = self._patterns['single_qubit'].search(line)
        if match:
            gate_name = match.group(1)
            ref = match.group(2)
            if ref in self._qubit_mapping:
                return QuantumGate(
                    name=gate_name,
                    target_qubits=[self._qubit_mapping[ref]],
                    gate_index=gate_index
                )
        
        return None
    
    def _parse_rotation_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse rotation gates using pre-compiled regex.
        
        MLIR format: quake.rz(1.570796) %1 : (f64, !quake.ref) -> ()
        
        Note: If the parameter is a kernel argument (e.g., %arg0), it will be
        set to 0.0 as a placeholder since the actual value is runtime-dependent.
        """
        match = self._patterns['rotation'].search(line)
        if match:
            gate_name = match.group(1)
            param_str = match.group(2)
            ref = match.group(3)
            
            # Parse parameter (may be a constant or variable reference)
            try:
                # Try to parse as float constant
                param = float(param_str.strip('%').strip())
            except ValueError:
                # If it's a variable reference (e.g., %arg0), use 0.0 as placeholder
                param = 0.0
            
            if ref in self._qubit_mapping:
                return QuantumGate(
                    name=gate_name,
                    target_qubits=[self._qubit_mapping[ref]],
                    parameters=[param],
                    gate_index=gate_index
                )
        
        return None
    
    def _parse_controlled_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse controlled gates using pre-compiled regex.
        
        MLIR formats:
            Single control: quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
            Multi-control:  quake.x [%1, %2] %3 : (!quake.ref, !quake.ref, !quake.ref) -> ()
        
        Supports: CX (CNOT), CY, CZ, and multi-controlled versions (e.g., Toffoli/CCX)
        """
        match = self._patterns['controlled'].search(line)
        if match:
            quake_name = match.group(1)  # 'x', 'y', or 'z'
            control_refs_str = match.group(2)  # e.g., "%1" or "%1, %2"
            target_ref = match.group(3)
            
            # Parse control qubits (may be multiple, separated by commas)
            control_refs = [ref.strip().strip('%') for ref in control_refs_str.split(',')]
            
            # Map references to qubit indices
            control_qubits = []
            for ref in control_refs:
                if ref not in self._qubit_mapping:
                    return None  # Invalid reference
                control_qubits.append(self._qubit_mapping[ref])
            
            # Check if target is valid
            if target_ref not in self._qubit_mapping:
                return None
            
            # Determine gate name based on number of controls
            num_controls = len(control_qubits)
            if num_controls == 1:
                gate_name = {'x': 'cx', 'y': 'cy', 'z': 'cz'}[quake_name]
            elif num_controls == 2 and quake_name == 'x':
                gate_name = 'ccx'  # Toffoli gate
            else:
                # For other multi-controlled gates, use descriptive names
                gate_name = f"c{'c' * (num_controls - 1)}{quake_name}"
            
            return QuantumGate(
                name=gate_name,
                target_qubits=[self._qubit_mapping[target_ref]],
                control_qubits=control_qubits,
                gate_index=gate_index
            )
        
        return None
    
    def _parse_swap_gate(self, line: str, gate_index: int) -> Optional[QuantumGate]:
        """
        Parse SWAP gate using pre-compiled regex.
        
        MLIR format: quake.swap %1, %2 : (!quake.ref, !quake.ref) -> ()
        """
        match = self._patterns['swap'].search(line)
        if match:
            ref1 = match.group(1)
            ref2 = match.group(2)
            
            if ref1 in self._qubit_mapping and ref2 in self._qubit_mapping:
                return QuantumGate(
                    name='swap',
                    target_qubits=[
                        self._qubit_mapping[ref1], 
                        self._qubit_mapping[ref2]
                    ],
                    gate_index=gate_index
                )
        
        return None


# ============================================================================
# Helper Functions
# ============================================================================

def _get_state_and_topology(kernel, state=None) -> Tuple[Any, List[QuantumGate], int]:
    """
    Helper function to get CUDA-Q state and parse topology.
    
    This eliminates code duplication in get_circuit_tensors and create_pytorch_converter.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        
    Returns:
        Tuple of (state, gates, num_qubits)
    """
    # Parse topology
    gates, num_qubits = parse_circuit_topology(kernel)
    
    # Get CUDA-Q state if not provided
    if state is None:
        state = cudaq.get_state(kernel)
    
    return state, gates, num_qubits


def _try_import_formotensor_bridge():
    """
    Attempt to import formotensor_bridge module.
    
    Provides helpful error message if module is not found.
    
    Returns:
        The formotensor_bridge module
        
    Raises:
        ImportError: If module cannot be imported with helpful instructions
    """
    try:
        import formotensor_bridge
        return formotensor_bridge
    except ImportError as e:
        raise ImportError(
            "Could not import 'formotensor_bridge' module. "
            "Please ensure it is built and in your PYTHON PATH.\n\n"
            "To build the module:\n"
            "  1. cd /path/to/FormoTensor/build/python\n"
            "  2. cmake ../../python\n"
            "  3. make -j$(nproc)\n\n"
            "To add to PYTHONPATH:\n"
            "  export PYTHONPATH=/path/to/FormoTensor/build/python:$PYTHONPATH\n\n"
            "Or install FormoTensor as a package (recommended):\n"
            "  pip install -e /path/to/FormoTensor\n"
        ) from e


def _try_import_converter():
    """
    Attempt to import CudaqToTorchConverter.
    
    Provides helpful error message if module is not found.
    
    Returns:
        The CudaqToTorchConverter class
        
    Raises:
        ImportError: If module cannot be imported with helpful instructions
    """
    try:
        from cudaq_to_torch_converter import CudaqToTorchConverter
        return CudaqToTorchConverter
    except ImportError as e:
        raise ImportError(
            "Could not import 'cudaq_to_torch_converter' module. "
            "Please ensure it is in your PYTHONPATH.\n\n"
            "To add to PYTHONPATH:\n"
            "  export PYTHONPATH=/path/to/FormoTensor/scripts:$PYTHONPATH\n\n"
            "Or install FormoTensor as a package (recommended):\n"
            "  pip install -e /path/to/FormoTensor\n"
        ) from e


# ============================================================================
# High-level API Functions
# ============================================================================

def parse_circuit_topology(kernel) -> Tuple[List[QuantumGate], int]:
    """
    Parse quantum circuit topology from a CUDA-Q kernel.
    
    This is the main entry point for extracting circuit topology.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        
    Returns:
        Tuple of (gates, num_qubits):
            - gates: List of QuantumGate objects in execution order
            - num_qubits: Total number of qubits in the circuit
    
    Examples:
        >>> @cudaq.kernel
        >>> def bell_state():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> gates, n_qubits = parse_circuit_topology(bell_state)
        >>> print(f"Circuit has {n_qubits} qubits and {len(gates)} gates")
        Circuit has 2 qubits and 2 gates
    """
    parser = MLIRCircuitParser()
    return parser.parse_kernel(kernel)


def print_circuit_topology(kernel) -> None:
    """
    Print a human-readable representation of circuit topology.
    
    Args:
        kernel: A @cudaq.kernel decorated function
    
    Examples:
        >>> @cudaq.kernel
        >>> def my_circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> print_circuit_topology(my_circuit)
        Circuit: 2 qubits, 2 gates
        ================================================================
        Gate 0: H
          Targets: [0]
        Gate 1: CX
          Targets: [1]
          Controls: [0]
        ================================================================
    """
    gates, num_qubits = parse_circuit_topology(kernel)
    
    print(f"Circuit: {num_qubits} qubits, {len(gates)} gates")
    print("=" * 64)
    
    for gate in gates:
        print(f"Gate {gate.gate_index}: {gate.name.upper()}")
        print(f"  Targets: {gate.target_qubits}")
        if gate.control_qubits:
            print(f"  Controls: {gate.control_qubits}")
        if gate.parameters:
            print(f"  Parameters: {gate.parameters}")
    
    print("=" * 64)


def get_circuit_tensors(kernel, state=None, return_metadata=False):
    """
    Extract circuit gate tensors as PyTorch tensors with topology metadata.
    
    This function extracts both the tensor data and topology information,
    returning them in a format suitable for quantum machine learning applications.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        return_metadata: If True, returns additional metadata
        
    Returns:
        If return_metadata=False (default):
            Tuple of (tensors, topology):
                - tensors: List of torch.Tensor objects (one per gate)
                - topology: List of QuantumGate objects
        
        If return_metadata=True:
            Dict with keys:
                - 'tensors': List of torch.Tensor objects
                - 'gates': List of QuantumGate objects
                - 'num_qubits': Total number of qubits
                - 'num_gates': Total number of gates
                - 'circuit_depth': Maximum circuit depth
    
    Examples:
        >>> @cudaq.kernel
        >>> def circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> tensors, gates = get_circuit_tensors(circuit)
        >>> print(f"H gate tensor shape: {tensors[0].shape}")
        H gate tensor shape: torch.Size([2, 2])
        >>> print(f"CNOT gate tensor shape: {tensors[1].shape}")
        CNOT gate tensor shape: torch.Size([2, 2, 2, 2])
        
        >>> # With metadata
        >>> data = get_circuit_tensors(circuit, return_metadata=True)
        >>> print(f"Circuit has {data['num_qubits']} qubits")
        Circuit has 2 qubits
    """
    # Import formotensor_bridge with helpful error messages
    ftb = _try_import_formotensor_bridge()
    
    # Get state and topology (using helper to avoid duplication)
    state, gates, num_qubits = _get_state_and_topology(kernel, state)
    
    # Extract tensors
    tensors = []
    for i, gate in enumerate(gates):
        tensor = ftb.TensorNetworkHelper.extract_tensor_data(state, i)
        tensors.append(tensor)
    
    if not return_metadata:
        return tensors, gates
    
    # Calculate circuit depth
    qubit_depths = [0] * num_qubits
    for gate in gates:
        involved_qubits = gate.target_qubits + gate.control_qubits
        max_depth = max(qubit_depths[q] for q in involved_qubits)
        for q in involved_qubits:
            qubit_depths[q] = max_depth + 1
    
    circuit_depth = max(qubit_depths) if qubit_depths else 0
    
    return {
        'tensors': tensors,
        'gates': gates,
        'num_qubits': num_qubits,
        'num_gates': len(gates),
        'circuit_depth': circuit_depth
    }


def create_pytorch_converter(kernel, state=None):
    """
    Create a PyTorch-based tensor network converter with automatic topology.
    
    This is the recommended high-level function for converting CUDA-Q circuits
    to PyTorch tensor networks.
    
    Args:
        kernel: A @cudaq.kernel decorated function
        state: Optional pre-computed cudaq.State object
        
    Returns:
        A CudaqToTorchConverter instance ready for contraction or manipulation
    
    Examples:
        >>> @cudaq.kernel
        >>> def circuit():
        ...     q = cudaq.qvector(2)
        ...     h(q[0])
        ...     cx(q[0], q[1])
        >>> 
        >>> # Create converter
        >>> converter = create_pytorch_converter(circuit)
        >>> 
        >>> # Contract to get final state
        >>> state_vector = converter.contract()
        >>> print(state_vector.flatten())
        tensor([0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j])
        >>> 
        >>> # Or get einsum expression
        >>> expr, tensors = converter.generate_einsum_expression()
        >>> print(f"Einsum: {expr}")
        Einsum: ca,decb->de
    """
    # Import required modules with helpful error messages
    CudaqToTorchConverter = _try_import_converter()
    ftb = _try_import_formotensor_bridge()
    
    # Get state and topology (using helper to avoid duplication)
    state, gates, num_qubits = _get_state_and_topology(kernel, state)
    
    # Create converter
    converter = CudaqToTorchConverter(num_qubits=num_qubits)
    
    # Add gates with topology
    for i, gate in enumerate(gates):
        tensor = ftb.TensorNetworkHelper.extract_tensor_data(state, i)
        converter.add_gate(
            tensor,
            targets=gate.target_qubits,
            controls=gate.control_qubits,
            name=gate.name
        )
    
    return converter


# Backward compatibility aliases
extract_topology_from_kernel = parse_circuit_topology
print_topology = print_circuit_topology
create_torch_converter_from_kernel = create_pytorch_converter


if __name__ == "__main__":
    # Simple test
    import numpy as np
    
    cudaq.set_target("tensornet")
    
    @cudaq.kernel
    def test_circuit():
        q = cudaq.qvector(2)
        h(q[0])
        cx(q[0], q[1])
    
    print("Testing MLIR Circuit Parser:")
    print_circuit_topology(test_circuit)

